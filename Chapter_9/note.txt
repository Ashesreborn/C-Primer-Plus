9.1
	
	1.函数(function)是完成特定任务的独立程序代码单元.语法规则定义了函数的结构和使用方式
	2.函数原型(function prototype)告诉编译器函数starbar()的类型
	  函数调用(function call)表明在此处执行函数
	  函数定义(function definition)明确地指定了函数要做什么
	3.一般而言,函数原型指明了函数的返回值类型和函数接受的参数类型.这些信息称为该函数的签名(signature)
	4.实际参数可以是常量,变量,或甚至是更复杂的表达式。无论实际参数是何种形式都要被求值,然后该值被拷贝给被调函数相应的形式参数
	5.调用函数时,创建了声明为形式参数的变量并初始化为实际参数的求值结果
	6.驱动程序(driver):用于测试函数的程序
	7.实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值
	8.return语句的另一个作用：终止函数并把控制返回给主调函数的下一条语句
	9.可以在函数中使用多个return语句
	10：return;
		终止函数,并把控制返回给主调函数,只有在void函数中才会用到这种形式
	11.函数类型指的是返回值的类型,不是函数参数的类型
	12.函数的前置声明可以放在主调函数外面,也可以放在主调函数里面
	13.函数声明告知编译器函数的类型,而函数定义则提供实际的代码

9.2
	
	1.主调函数把它的参数储存在被称为栈(stack)的临时存储区,被调函数从栈中读取这些参数
	2.主调函数根据函数调用中的实际参数决定传递的类型,而被调函数根据它的形式参数读取值
	3.float类型被作为参数传递时会被升级为double类型
	4.ANSI C标准要求在函数声明时还要声明变量的类型,即使用函数原型(function prototype)来声明函数的返回类型,参数的数量和每个参数的类型
	5.函数原型中的变量名是假名,不必与函数定义的形式参数名一样
	6.错误导致无法编译,而警告仍然允许编译
	7.函数原型让编译器捕获在使用函数时可能出现的许多错误或疏漏

9.3

	1.递归方案更简洁,但效率没有循环高
	2.递归函数中位于递归调用之前的语句,均按被调函数的顺序执行
	3.递归函数中位于递归调用之后的语句,均按被调函数相反的顺序执行
	4.尾递归(tail recursion):把递归置于函数的末尾,即正好在return语句之前
	5.factorial(阶乘)
	6.一般而言,选择循环比递归好:
		(1).每次递归都会创建一组变量,所以递归使用的内存更多,而且每次递归调用都会把创建的一组新变量放在栈中.递归调用的数量受限于内存空间。
		(2).每次递归调用要花费一定的时间,所以递归的执行速度较慢。
	7.递归在处理倒序时非常方便
	8.二进制中,奇数末尾一定是1,偶数末尾一定是0
	9.计算的第一位数字实际上是待输出二进制数的最后一位
	10.在递归函数的递归调用之前计算n % 2,在递归调用之后打印计算结果.这样,计算的第一个值正好是最后一个打印的值

9.5
	1.每个C函数都有自己的变量,这样做可以防止原始变量被被调函数中的副作用意外修改

9.6
	
	1.用return语句只能把被调函数中的一个值传回主调函数

9.7
	
	1.指针(pinter)是一个值为内存地址的变量
	2.间接运算符(indirection operator)找出储存在bah中的值,该运算符有时也称为解引运算符(dereferencing operator)
	3.val = *ptr;
	  int * pi;			(pi是一个指针,*pi是int类型)
	  char * pc;
	  float * pf, * pg;
	4.*和指针名之间的空格可有可无,通常，程序员在声明时使用空格，在解引用变量时省略空格
	5.指向**类型的指针，指针的值是一个地址,在大部分系统内部,该地址有一个无符号整数表示
	6.ANSI C专门为指针提供了%p格式的转换说明
	7.编写程序时,可以认为变量有两个属性:名称和值。计算机编译和加载程序后,认为变量也有两个属性；地址和值。地址旧式变量在计算机内部的名称
	8.普通变量把值作为基本量,把地址作为&运算符获得的派生量,而指针变量把地址作为基本量,把值作为通过*运算符获得的派生量