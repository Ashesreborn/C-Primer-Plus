8.2
	
	1.回显用户输入的字符后立即重复打印该字符是属于无缓冲(或直接)输入，即正在等待的程序可立即使用输入的字符
	2.用户按下Enter键之前不会重复打印刚输入的字符,这种输入形式属于缓冲输入
	3.用户输入的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区,按下Enter键后,程序才可使用用户输入的字符
	4.为什么要有缓冲区：
	  (1).把若干字符作为一个块进行传输比卓格发送这些字符节约时间
	  (2).如果用户打错字符,可以直接通过键盘修正错误，当最后按下Enter键时,传输的是正确的输入
	5.无缓冲输入:游戏中,你希望按下一个键就执行相应的指令
	6.缓冲分为两类:
	  (1).完全缓冲I/O:当缓冲区被装满时才刷新缓冲区(内容被发送至目的地),通常出现在文件输入中
	  (2).行缓冲I/O:出现换行符时刷新缓冲区,键盘输入通常是行缓冲输入
	7.缓冲区的大小取决于系统,常见的大小时512字节和4096字节
	8.ANSI C和后续的C标准都规定输入是缓冲的
	9.ANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲输入

8.3

	1.文件(file)是存储器中储存信息的区域
	2.底层I/O(low-level I/O):直接调用操作系统的函数
	3.较高层面上,C通过标准I/O(standard I/O package)来处理文件,在这一层面上,具体的C实现负责处理不同系统的差异,以便用户使用统一的界面
	4.不同系统的差异:不同系统储存文件的方式不同,处理文件方面，标记行末尾的方式不同,衡量文件大小的方式不同
	5.如果使用标准I/O包,则不用考虑不同系统的差异，因此,可以用if(ch == '\n')检查换行符.即使系统实际用的是回车符和换行符的组合来标记行末尾,I/O函数会在两者表示法之间相互切换
	6.从概念上看,C程序处理的是流而不是直接处理文件。
	7.流(stream)是一个实际输入或映射映射的理想化数据流。这意味着不同属性和不同种类的输入,由属性更统一的流来表示
	8.打开文件的过程就是把流与文件相关联,而且读写都通过流来完成
	9.C把输入和输出设备视为存储设备上的普通文件,尤其是把键盘和显示设备视为每个C程序自动打开的文件
	10.stdin流表示键盘输入,stdout流表示屏幕输出
	11.getchar(),putchar(),printf(),scanf()函数都不是标准I/O包的成员,处理两个流
	12.可以用处理文件的方式来处理键盘输入
	13.检测文件的结尾:1.使用内嵌的Ctrl+Z字符来标记文件的结尾
					  2.储存文件大小的信息(MS-DOS及其相关系统使用这种方法处理二进制文件,新版的DOS使用这种方法处理文本文件,UNIX使用这种方法处理所有的文件)
	14.无论操作系统使用何种方法检测文件的结尾,在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值,即EOF(end of file的缩写)
	15.scanf()函数检测到文件结尾时也返回EOF,通常,EOF定义在stdio.h文件中
	16.#define EOF (-1)
	17.EOF是一个值,标志着检测到文件结尾,并不是在文件中找得到的符号

8.4
	
	1.默认情况下,C程序使用标准I/O包查找标准输入作为输入源,即stdin流
	2.程序通过两种方式使用文件:
		(1).显式使用特定的函数打开文件,关闭文件,读取文件,写入文件
		(2).设计能与键盘和屏幕互动的程序,通过不同的渠道重定向输入至文件和从文件输出。换言之,把stdin流重新赋给文件.继续使用getchar()函数从输入流中获取数据,但它并不关心从流的什么位置获取数据
	3.重定向的一个主要问题是它与操作系统有关,与C无关
	4.重定向输入让程序使用文件而不是让键盘赖输入,重定向输入让程序输出至文件而不是屏幕
	5.重定向输入:
		(1). < 符号是UNIX和DOS/Windows的重定向运算符，该定向符使文本文件与stdin流相关联,把文件的内容导入echo_eof程序,echo_eof程序本身并不知道(或不关心)输入的内容是来自文件还是键盘，它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直到读到文件结尾
	6.C把文件和I/O设备放在一个层面上,所以文件就是现在的I/O设备
	7.重定向输出:
		(1). > 是第二个重定向运算符，重定向把stdout从显示设备(即,显示器)赋给mywords文件,如果已经有一个同名的文件,通常会擦除该文件的内容,然后替换新的内容。所有出现在屏幕上的字母都是你刚才输入的,其副本储存在文件中
	8.使用重定向运算符遵循原则:
		(1).重定向运算符连接一个可执行程序(包括标准操作系统命令)和一个数据文件,不能用于连接一个数据文件和另一个数据文件,也不能用于连接一个程序和另一个程序
		(2).使用重定向运算符不能读取多个文件的输入,也不能把输出定向至多个文件.
		(3).文件名和运算符之间的空格不是必须的,除非是偶尔在UNIXsheel、Linuxshell或Windows命令行提示模式中使用的有特殊含义的字符。
	9.UNIX、Linux或Windows/DOS还有>>运算符,该运算符可以把数据添加到现有文件的末尾,而|运算符能把一个文件的输出连接到另一个文件的输入

8.5
	
	1.解决输入时将\n当作一个字符:
		(1).使用while循环丢弃输入行最后输入的内容,包括换行符。优点:能把no 和no way这样的响应视为简单的n
	2.getchar()读取每个字符,包括空格、制表符和换行符;而scanf()在读取数字时则会跳过空格、制表符和换行符
 8.6

 	1.输入由字符组成,但是scanf()可以把输入转换成整数值或是浮点数值

 8.7

 	1.使用图形界面更容易通过限制选项控制输入
 	2.函数跳过换行符:
 		(1).用名为get_first()的新函数替换getchar()函数,读取一行的第一个字符并丢弃剩余的字符，把类似act这样的输入视为简单的a

8.8
	
	1.C程序把输入作为传入的字节流.getchar()函数把每个字符解释成一个字符编码,scanf()函数以同样的方式看待输入,但是根据转换说明,它可以把字符输入转换成数值