10.1
	
	1.数组由数据类型相同的一系列元素组成
	2.标量变量(scalar variable):只储存单个值的变量
	3.用以逗号分隔的值列表来初始化数组,各值之间用逗号分隔,在逗号和值之间可以使用空格
	4.用const声明和初始化的数组为只读数组,
	5.一旦声明为const，便不能再给它赋值
	6.自动存储类别:数组在函数内声明,且声明时未使用关键字static
	7.当初始化类表中的值少于数组元素个数时,编译器会把剩余的元素都初始化为0
	8.如果未初始化数组,数组元素和未初始化的普通变量一样,其中储存的都是垃圾值,但是,如果部分初始化数组,剩余的元素就会被初始化为0
	9.如果初始化立标的项数多于数组元素的个数,编译器可没那么仁慈，它会毫不留情地将其视为错误
	10.C99增加了一个新特性：指定初始化器(designated initializer).利用该特性可以初始化指定的数组元素
		int arr[6] = {[5] = 212};
	11.如果指定的初始化器后面有更多的值,那么后面这些值将被用于初始化指定元素后面的元素
	12.如果再次初始化指定的元素,那么最后的初始化将会取代之前的初始化
	13.整型常量表达式:整型常量构成的表达式，表达式的值必须大于0
	14.float rain[5][12];		//内含5个元素的数组

10.3
	
	1.指针提供一种以符号形式使用地址的方法
	2.flizny和&flizny[0]都表示数组首元素的内存地址,两者都是常量
	3.在C中,指针加 1 指的是增加一个存储单元
	4.指针的值是他所指对象的的地址,地址的表示方式以赖于计算机内部的硬件
	5.在指针前面使用*运算符可以得到该指针所指向对象的值
	6.指针加一,指针的值递增它所指向类型的大小(以字节为单位)
		(1).dates + 2 == &dates[2]				//相同的地址
		(2).*(dates + 2) == dates[2]			//相同的值
	7.*(ar + n):到内存的ar位置,然后移动n个单元,检索储存在哪里的值
	8.间接运算符(*)的优先级高于+

10.4
	
	1.可以使用指针表示数组名,也可以使用数组名表示指针
	2.只有在函数原型或函数定义头中,才可以使用int ar[]代替int * ar:
		int sum (int ar[], int n);
		int *ar形式和int ar[]形式都表示ar是一个指向int的指针。但是,int ar[]只能用于声明形式参数。第二种形式( int ar[])提醒读者指针ar指向的不仅仅一个int类型值,还是一个int类型数组的元素
	3.函数原型可以省略参数名,但是函数定义中不能省略参数名
	4.指针形参是变量,这意味着可以用索引表明访问数组中的哪一个元素
	5.处理数组的函数时间上用指针作为参数
	6.只有当ar是指针变量时,才能使用ar++这样的表达式
	7.解引用：*运算符给出指针指向地址上储存的值
	8.指针指向超过数组末尾的第一个位置,C保证该指针有效
	9.创建一个指针时,系统只分配了储存指针本身的内存,并未分配储存数据的内存,因此,在使用指针之前,必须先用已分配的地址初始化它
	10.不要解引用未初始化的指针
	11.指针数组,函数指针,指向指针的指针数组,指向函数的指针数组
	12.按值传递数据可以保证数据的完整性

10.6

	1.如果不想修改数组中的数据内容,可以在函数原型和函数定义中声明形式参数时使用关键字const
	2.使用const并不是要求原数组是常量,而是该函数在处理数组时将其视为常量,不可更改
	3.指向const的指针不能用于改变值，通常用于函数形参中，表明该函数不会使用指针改变数据
	4.只能把非const数据的地址赋给普通指针
	5.int (*pz)[2];					//pz指向一个内含两个int型值的数组
	6.[]的优先级高于()
	7.把const指针赋给非const指针不安全
	  把非const指针赋给const指针有效
	8.void somefunction( int (* pt)[4]);
	  当且仅当pt是一个函数的形式参数时,可以这样声明:
	  void somefunction( int pt[][4]  );

10.7
	
	1.一般而言,声明一个指向N维数组的指针时,只能省略最左边方括号中的值：
		int sum4d(int ar[][12][20][30], int rows);
	  因为第一对方括号值用于表明这是一个指针,而其他方括号则用于秒素指针所指向数据对象的类型。下面的声明与该声明等价：
	  	int sum4d(int (*ar)[12][20][30], int rows);			//ar是一个指针
	  这里,ar指向一个12x20x30的int数组
	2.编译器会把数组表示法转换成指针表示法

10.8
	
	1.C99新增了变长数组(variable-length array, VLA),允许使用变量表示数组的维度
	2.变长数组必须是自动存储类别,这意味着无论是在函数中声明还是作为函数形参声明,都不能使用static或extern存储类别说明符.而且不能在声明中初始化他们
	3.C11把变长数组作为一个可选特性,而不是鼻息强制实现的特性

10.9
	
	1.C99新增了复合字面量(compound literal).字面量是除符号常量外的常量
	2.因为复合字面量是匿名的,所以不能先创建再使用它,必须在创建的时候使用它

10.10
	
	1.C把数组看作是派生类型,因为数组是建立在其他类型的基础上
	2.在把数组名作为实际参数时,传递给函数的不是整个数组,而是数组的地址(因此，函数对应的形式参数是指针)
	3.C把数组名解释为数组首元素的地址.换言之，数组名与指向该数组首元素的指针等价
	4.如果函数没有修改原始数组的意图,应在声明函数的形式参数时使用关键字const 